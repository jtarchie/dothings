// Code generated by counterfeiter. DO NOT EDIT.
package stepsfakes

import (
	"io"
	"sync"
)

type FakeContainerManager struct {
	CommandStub        func(string, ...string)
	commandMutex       sync.RWMutex
	commandArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	EnvVarStub        func(string, string)
	envVarMutex       sync.RWMutex
	envVarArgsForCall []struct {
		arg1 string
		arg2 string
	}
	ImageStub        func(string, string)
	imageMutex       sync.RWMutex
	imageArgsForCall []struct {
		arg1 string
		arg2 string
	}
	ImageFromOCIStub        func(string)
	imageFromOCIMutex       sync.RWMutex
	imageFromOCIArgsForCall []struct {
		arg1 string
	}
	PrivilegedStub        func(bool)
	privilegedMutex       sync.RWMutex
	privilegedArgsForCall []struct {
		arg1 bool
	}
	RunStub        func(io.Reader, io.Writer, io.Writer) error
	runMutex       sync.RWMutex
	runArgsForCall []struct {
		arg1 io.Reader
		arg2 io.Writer
		arg3 io.Writer
	}
	runReturns struct {
		result1 error
	}
	runReturnsOnCall map[int]struct {
		result1 error
	}
	UserStub        func(string)
	userMutex       sync.RWMutex
	userArgsForCall []struct {
		arg1 string
	}
	VolumeStub        func(string, string)
	volumeMutex       sync.RWMutex
	volumeArgsForCall []struct {
		arg1 string
		arg2 string
	}
	WorkingDirStub        func(string)
	workingDirMutex       sync.RWMutex
	workingDirArgsForCall []struct {
		arg1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeContainerManager) Command(arg1 string, arg2 ...string) {
	fake.commandMutex.Lock()
	fake.commandArgsForCall = append(fake.commandArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2})
	fake.recordInvocation("Command", []interface{}{arg1, arg2})
	fake.commandMutex.Unlock()
	if fake.CommandStub != nil {
		fake.CommandStub(arg1, arg2...)
	}
}

func (fake *FakeContainerManager) CommandCallCount() int {
	fake.commandMutex.RLock()
	defer fake.commandMutex.RUnlock()
	return len(fake.commandArgsForCall)
}

func (fake *FakeContainerManager) CommandCalls(stub func(string, ...string)) {
	fake.commandMutex.Lock()
	defer fake.commandMutex.Unlock()
	fake.CommandStub = stub
}

func (fake *FakeContainerManager) CommandArgsForCall(i int) (string, []string) {
	fake.commandMutex.RLock()
	defer fake.commandMutex.RUnlock()
	argsForCall := fake.commandArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerManager) EnvVar(arg1 string, arg2 string) {
	fake.envVarMutex.Lock()
	fake.envVarArgsForCall = append(fake.envVarArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("EnvVar", []interface{}{arg1, arg2})
	fake.envVarMutex.Unlock()
	if fake.EnvVarStub != nil {
		fake.EnvVarStub(arg1, arg2)
	}
}

func (fake *FakeContainerManager) EnvVarCallCount() int {
	fake.envVarMutex.RLock()
	defer fake.envVarMutex.RUnlock()
	return len(fake.envVarArgsForCall)
}

func (fake *FakeContainerManager) EnvVarCalls(stub func(string, string)) {
	fake.envVarMutex.Lock()
	defer fake.envVarMutex.Unlock()
	fake.EnvVarStub = stub
}

func (fake *FakeContainerManager) EnvVarArgsForCall(i int) (string, string) {
	fake.envVarMutex.RLock()
	defer fake.envVarMutex.RUnlock()
	argsForCall := fake.envVarArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerManager) Image(arg1 string, arg2 string) {
	fake.imageMutex.Lock()
	fake.imageArgsForCall = append(fake.imageArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("Image", []interface{}{arg1, arg2})
	fake.imageMutex.Unlock()
	if fake.ImageStub != nil {
		fake.ImageStub(arg1, arg2)
	}
}

func (fake *FakeContainerManager) ImageCallCount() int {
	fake.imageMutex.RLock()
	defer fake.imageMutex.RUnlock()
	return len(fake.imageArgsForCall)
}

func (fake *FakeContainerManager) ImageCalls(stub func(string, string)) {
	fake.imageMutex.Lock()
	defer fake.imageMutex.Unlock()
	fake.ImageStub = stub
}

func (fake *FakeContainerManager) ImageArgsForCall(i int) (string, string) {
	fake.imageMutex.RLock()
	defer fake.imageMutex.RUnlock()
	argsForCall := fake.imageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerManager) ImageFromOCI(arg1 string) {
	fake.imageFromOCIMutex.Lock()
	fake.imageFromOCIArgsForCall = append(fake.imageFromOCIArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ImageFromOCI", []interface{}{arg1})
	fake.imageFromOCIMutex.Unlock()
	if fake.ImageFromOCIStub != nil {
		fake.ImageFromOCIStub(arg1)
	}
}

func (fake *FakeContainerManager) ImageFromOCICallCount() int {
	fake.imageFromOCIMutex.RLock()
	defer fake.imageFromOCIMutex.RUnlock()
	return len(fake.imageFromOCIArgsForCall)
}

func (fake *FakeContainerManager) ImageFromOCICalls(stub func(string)) {
	fake.imageFromOCIMutex.Lock()
	defer fake.imageFromOCIMutex.Unlock()
	fake.ImageFromOCIStub = stub
}

func (fake *FakeContainerManager) ImageFromOCIArgsForCall(i int) string {
	fake.imageFromOCIMutex.RLock()
	defer fake.imageFromOCIMutex.RUnlock()
	argsForCall := fake.imageFromOCIArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainerManager) Privileged(arg1 bool) {
	fake.privilegedMutex.Lock()
	fake.privilegedArgsForCall = append(fake.privilegedArgsForCall, struct {
		arg1 bool
	}{arg1})
	fake.recordInvocation("Privileged", []interface{}{arg1})
	fake.privilegedMutex.Unlock()
	if fake.PrivilegedStub != nil {
		fake.PrivilegedStub(arg1)
	}
}

func (fake *FakeContainerManager) PrivilegedCallCount() int {
	fake.privilegedMutex.RLock()
	defer fake.privilegedMutex.RUnlock()
	return len(fake.privilegedArgsForCall)
}

func (fake *FakeContainerManager) PrivilegedCalls(stub func(bool)) {
	fake.privilegedMutex.Lock()
	defer fake.privilegedMutex.Unlock()
	fake.PrivilegedStub = stub
}

func (fake *FakeContainerManager) PrivilegedArgsForCall(i int) bool {
	fake.privilegedMutex.RLock()
	defer fake.privilegedMutex.RUnlock()
	argsForCall := fake.privilegedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainerManager) Run(arg1 io.Reader, arg2 io.Writer, arg3 io.Writer) error {
	fake.runMutex.Lock()
	ret, specificReturn := fake.runReturnsOnCall[len(fake.runArgsForCall)]
	fake.runArgsForCall = append(fake.runArgsForCall, struct {
		arg1 io.Reader
		arg2 io.Writer
		arg3 io.Writer
	}{arg1, arg2, arg3})
	fake.recordInvocation("Run", []interface{}{arg1, arg2, arg3})
	fake.runMutex.Unlock()
	if fake.RunStub != nil {
		return fake.RunStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.runReturns
	return fakeReturns.result1
}

func (fake *FakeContainerManager) RunCallCount() int {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	return len(fake.runArgsForCall)
}

func (fake *FakeContainerManager) RunCalls(stub func(io.Reader, io.Writer, io.Writer) error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = stub
}

func (fake *FakeContainerManager) RunArgsForCall(i int) (io.Reader, io.Writer, io.Writer) {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	argsForCall := fake.runArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeContainerManager) RunReturns(result1 error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = nil
	fake.runReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerManager) RunReturnsOnCall(i int, result1 error) {
	fake.runMutex.Lock()
	defer fake.runMutex.Unlock()
	fake.RunStub = nil
	if fake.runReturnsOnCall == nil {
		fake.runReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerManager) User(arg1 string) {
	fake.userMutex.Lock()
	fake.userArgsForCall = append(fake.userArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("User", []interface{}{arg1})
	fake.userMutex.Unlock()
	if fake.UserStub != nil {
		fake.UserStub(arg1)
	}
}

func (fake *FakeContainerManager) UserCallCount() int {
	fake.userMutex.RLock()
	defer fake.userMutex.RUnlock()
	return len(fake.userArgsForCall)
}

func (fake *FakeContainerManager) UserCalls(stub func(string)) {
	fake.userMutex.Lock()
	defer fake.userMutex.Unlock()
	fake.UserStub = stub
}

func (fake *FakeContainerManager) UserArgsForCall(i int) string {
	fake.userMutex.RLock()
	defer fake.userMutex.RUnlock()
	argsForCall := fake.userArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainerManager) Volume(arg1 string, arg2 string) {
	fake.volumeMutex.Lock()
	fake.volumeArgsForCall = append(fake.volumeArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("Volume", []interface{}{arg1, arg2})
	fake.volumeMutex.Unlock()
	if fake.VolumeStub != nil {
		fake.VolumeStub(arg1, arg2)
	}
}

func (fake *FakeContainerManager) VolumeCallCount() int {
	fake.volumeMutex.RLock()
	defer fake.volumeMutex.RUnlock()
	return len(fake.volumeArgsForCall)
}

func (fake *FakeContainerManager) VolumeCalls(stub func(string, string)) {
	fake.volumeMutex.Lock()
	defer fake.volumeMutex.Unlock()
	fake.VolumeStub = stub
}

func (fake *FakeContainerManager) VolumeArgsForCall(i int) (string, string) {
	fake.volumeMutex.RLock()
	defer fake.volumeMutex.RUnlock()
	argsForCall := fake.volumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerManager) WorkingDir(arg1 string) {
	fake.workingDirMutex.Lock()
	fake.workingDirArgsForCall = append(fake.workingDirArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("WorkingDir", []interface{}{arg1})
	fake.workingDirMutex.Unlock()
	if fake.WorkingDirStub != nil {
		fake.WorkingDirStub(arg1)
	}
}

func (fake *FakeContainerManager) WorkingDirCallCount() int {
	fake.workingDirMutex.RLock()
	defer fake.workingDirMutex.RUnlock()
	return len(fake.workingDirArgsForCall)
}

func (fake *FakeContainerManager) WorkingDirCalls(stub func(string)) {
	fake.workingDirMutex.Lock()
	defer fake.workingDirMutex.Unlock()
	fake.WorkingDirStub = stub
}

func (fake *FakeContainerManager) WorkingDirArgsForCall(i int) string {
	fake.workingDirMutex.RLock()
	defer fake.workingDirMutex.RUnlock()
	argsForCall := fake.workingDirArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainerManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.commandMutex.RLock()
	defer fake.commandMutex.RUnlock()
	fake.envVarMutex.RLock()
	defer fake.envVarMutex.RUnlock()
	fake.imageMutex.RLock()
	defer fake.imageMutex.RUnlock()
	fake.imageFromOCIMutex.RLock()
	defer fake.imageFromOCIMutex.RUnlock()
	fake.privilegedMutex.RLock()
	defer fake.privilegedMutex.RUnlock()
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	fake.userMutex.RLock()
	defer fake.userMutex.RUnlock()
	fake.volumeMutex.RLock()
	defer fake.volumeMutex.RUnlock()
	fake.workingDirMutex.RLock()
	defer fake.workingDirMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeContainerManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
